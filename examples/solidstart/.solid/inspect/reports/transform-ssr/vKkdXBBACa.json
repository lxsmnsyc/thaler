{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/session/cookie.ts","transforms":[{"name":"__load__","result":"/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n// Type definitions for cookie 0.5\n// Project: https://github.com/jshttp/cookie\n// Definitions by: Pine Mizune <https://github.com/pine>\n//                 Piotr Błażejewicz <https://github.com/peterblazejewicz>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/**\n * Basic HTTP cookie parser and serializer for HTTP servers.\n */\n\n/**\n * Additional serialization options\n */\nexport interface CookieSerializeOptions {\n  /**\n   * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n   * domain is set, and most clients will consider the cookie to apply to only\n   * the current domain.\n   */\n  domain?: string | undefined;\n\n  /**\n   * Specifies a function that will be used to encode a cookie's value. Since\n   * value of a cookie has a limited character set (and must be a simple\n   * string), this function can be used to encode a value into a string suited\n   * for a cookie's value.\n   *\n   * The default function is the global `encodeURIComponent`, which will\n   * encode a JavaScript string into UTF-8 byte sequences and then URL-encode\n   * any that fall outside of the cookie range.\n   */\n  encode?(value: string): string;\n\n  /**\n   * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n   * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n   * it on a condition like exiting a web browser application.\n   *\n   * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n   * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n   * possible not all clients by obey this, so if both are set, they should\n   * point to the same date and time.\n   */\n  expires?: Date | undefined;\n  /**\n   * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n   * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n   * default, the `HttpOnly` attribute is not set.\n   *\n   * *Note* be careful when setting this to true, as compliant clients will\n   * not allow client-side JavaScript to see the cookie in `document.cookie`.\n   */\n  httpOnly?: boolean | undefined;\n  /**\n   * Specifies the number (in seconds) to be the value for the `Max-Age`\n   * `Set-Cookie` attribute. The given number will be converted to an integer\n   * by rounding down. By default, no maximum age is set.\n   *\n   * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n   * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n   * possible not all clients by obey this, so if both are set, they should\n   * point to the same date and time.\n   */\n  maxAge?: number | undefined;\n  /**\n   * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n   * By default, the path is considered the \"default path\".\n   */\n  path?: string | undefined;\n  /**\n   * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n   *\n   * - `'low'` will set the `Priority` attribute to `Low`.\n   * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n   * - `'high'` will set the `Priority` attribute to `High`.\n   *\n   * More information about the different priority levels can be found in\n   * [the specification][rfc-west-cookie-priority-00-4.1].\n   *\n   * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n   * This also means many clients may ignore this attribute until they understand it.\n   */\n  priority?: \"low\" | \"medium\" | \"high\" | undefined;\n  /**\n   * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n   *\n   * - `true` will set the `SameSite` attribute to `Strict` for strict same\n   * site enforcement.\n   * - `false` will not set the `SameSite` attribute.\n   * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n   * enforcement.\n   * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n   * site enforcement.\n   *  - `'none'` will set the SameSite attribute to None for an explicit\n   *  cross-site cookie.\n   *\n   * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n   *\n   * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n   */\n  sameSite?: true | false | \"lax\" | \"strict\" | \"none\" | undefined;\n  /**\n   * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n   * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n   *\n   * *Note* be careful when setting this to `true`, as compliant clients will\n   * not send the cookie back to the server in the future if the browser does\n   * not have an HTTPS connection.\n   */\n  secure?: boolean | undefined;\n}\n\n/**\n * Additional parsing options\n */\nexport interface CookieParseOptions {\n  /**\n   * Specifies a function that will be used to decode a cookie's value. Since\n   * the value of a cookie has a limited character set (and must be a simple\n   * string), this function can be used to decode a previously-encoded cookie\n   * value into a JavaScript string or other object.\n   *\n   * The default function is the global `decodeURIComponent`, which will decode\n   * any URL-encoded sequences into their byte representations.\n   *\n   * *Note* if an error is thrown from this function, the original, non-decoded\n   * cookie value will be returned as the cookie's value.\n   */\n  decode?(value: string): string;\n}\n\n/**\n * Parse an HTTP Cookie header string and returning an object of all cookie\n * name-value pairs.\n *\n * @param str the string representing a `Cookie` header value\n * @param [options] object containing parsing options\n */\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\nexport function parseCookie(str: string, options?: CookieParseOptions): Record<string, string> {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  var obj: Record<string, any> = {};\n  var opt = options || {};\n  var pairs = str.split(\";\");\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf(\"=\");\n\n    // skip things that don't look like key=value\n    if (index < 0) {\n      continue;\n    }\n\n    var key = pair.substring(0, index).trim();\n\n    // only assign once\n    if (undefined == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim();\n\n      // quoted values\n      if (val[0] === '\"') {\n        val = val.slice(1, -1);\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\n/**\n * Serialize a cookie name-value pair into a `Set-Cookie` header string.\n *\n * @param name the name for the cookie\n * @param value value to set the cookie to\n * @param [options] object containing serialization options\n * @throws {TypeError} when `maxAge` options is invalid\n */\nexport function serializeCookie(\n  name: string,\n  value: string,\n  options?: CookieSerializeOptions\n): string;\nexport function serializeCookie(name: string, val: string, options?: CookieSerializeOptions) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n\n  var str = name + \"=\" + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n\n    str += \"; Domain=\" + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n\n    str += \"; Path=\" + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str: string, decode: (str: string) => string) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n","start":1681089269572,"end":1681089269572},{"name":"vite:esbuild","result":"/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nexport function parseCookie(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  var obj = {};\n  var opt = options || {};\n  var pairs = str.split(\";\");\n  var dec = opt.decode || decode;\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf(\"=\");\n    if (index < 0) {\n      continue;\n    }\n    var key = pair.substring(0, index).trim();\n    if (void 0 == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim();\n      if (val[0] === '\"') {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n  return obj;\n}\nexport function serializeCookie(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  var value = enc(val);\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  var str = name + \"=\" + value;\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\n","start":1681089269572,"end":1681089269606,"order":"normal"},{"name":"vite:define","result":"/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nexport function parseCookie(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  var obj = {};\n  var opt = options || {};\n  var pairs = str.split(\";\");\n  var dec = opt.decode || decode;\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf(\"=\");\n    if (index < 0) {\n      continue;\n    }\n    var key = pair.substring(0, index).trim();\n    if (void 0 == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim();\n      if (val[0] === '\"') {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n  return obj;\n}\nexport function serializeCookie(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  var value = enc(val);\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  var str = name + \"=\" + value;\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\n","start":1681089269606,"end":1681089269606,"order":"normal"},{"name":"vite:import-analysis","result":"/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nexport function parseCookie(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  var obj = {};\n  var opt = options || {};\n  var pairs = str.split(\";\");\n  var dec = opt.decode || decode;\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var index = pair.indexOf(\"=\");\n    if (index < 0) {\n      continue;\n    }\n    var key = pair.substring(0, index).trim();\n    if (void 0 == obj[key]) {\n      var val = pair.substring(index + 1, pair.length).trim();\n      if (val[0] === '\"') {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n  return obj;\n}\nexport function serializeCookie(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  var value = enc(val);\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  var str = name + \"=\" + value;\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\n","start":1681089269606,"end":1681089269606,"order":"normal"}]}
