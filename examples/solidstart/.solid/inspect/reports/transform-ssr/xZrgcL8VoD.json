{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/data/createRouteData.tsx","transforms":[{"name":"__load__","result":"import type {\n  Resource,\n  ResourceFetcher, ResourceFetcherInfo, ResourceOptions, Signal\n} from \"solid-js\";\nimport {\n  createResource,\n  onCleanup,\n  startTransition, untrack, useContext\n} from \"solid-js\";\nimport type { ReconcileOptions } from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\n\ninterface RouteDataEvent extends ServerFunctionEvent {}\n\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\n\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\n\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\n\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\n\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options?: RouteDataOptions<undefined, S>\n): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S>\n): Resource<T>;\nexport function createRouteData<T, S>(\n  fetcher?: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}\n): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n\n      if (key == true) return fetcher(key, info);\n\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n\n  const [resource, { refetch }] = createResource<T, S>(\n    (options.key || true) as RouteDataSource<S>,\n    dedupe(resourceFetcher),\n    {\n      storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n      ...options\n    } as any\n  );\n\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n\n  return resource;\n}\n\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\n\nfunction createDeepSignal<T>(value: T, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [\n    () => store.value,\n    (v: T) => {\n      const unwrapped = untrack(() => unwrap(store.value));\n      typeof v === \"function\" && (v = v(unwrapped));\n      setStore(\"value\", reconcile(v, options));\n      return store.value;\n    }\n  ] as Signal<T>;\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n\nfunction ensureQueryKeyArray<V extends any | any[], R = V extends [] ? V : [V]>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a.length && !b.length) return false;\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n","start":1681089269467,"end":1681089269467},{"name":"solid","result":"import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT } from \"../server/types\";\nconst resources = new Set();\nconst promises = new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async key => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true) return fetcher(key, info);\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: init => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, v => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length) return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}","start":1681089269467,"end":1681089269502,"order":"pre"},{"name":"vite:define","result":"import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT } from \"../server/types\";\nconst resources = new Set();\nconst promises = new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async key => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true) return fetcher(key, info);\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: init => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, v => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length) return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}","start":1681089269502,"end":1681089269502,"order":"normal"},{"name":"vite:import-analysis","result":"import { createResource, onCleanup, startTransition, untrack, useContext } from \"solid-js\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/router.tsx\";\nimport { isRedirectResponse, LocationHeader } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/responses.ts\";\nimport { ServerContext } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/ServerContext.tsx\";\nimport { FETCH_EVENT } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/types.tsx\";\nconst resources = new Set();\nconst promises = new Map();\nexport function createRouteData(fetcher, options = {}) {\n  const navigate = useNavigate();\n  const pageEvent = useContext(ServerContext);\n  function handleResponse(response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n  const resourceFetcher = async key => {\n    try {\n      let event = pageEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n      let response = await fetcher.call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n      }\n      return response;\n    } catch (e) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e), 0);\n        }\n        return e;\n      }\n      throw e;\n    }\n  };\n  function dedupe(fetcher) {\n    return (key, info) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n      if (key == true) return fetcher(key, info);\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info);\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n  const [resource, {\n    refetch\n  }] = createResource(options.key || true, dedupe(resourceFetcher), {\n    storage: init => createDeepSignal(init, options.reconcileOptions),\n    ...options\n  });\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n  return resource;\n}\nexport function refetchRouteData(key) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [() => store.value, v => {\n    const unwrapped = untrack(() => unwrap(store.value));\n    typeof v === \"function\" && (v = v(unwrapped));\n    setStore(\"value\", reconcile(v, options));\n    return store.value;\n  }];\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\nfunction ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a.length && !b.length) return false;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  return false;\n}","start":1681089269502,"end":1681089269508,"order":"normal"}]}
