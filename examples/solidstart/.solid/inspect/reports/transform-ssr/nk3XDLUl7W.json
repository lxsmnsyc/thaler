{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/entry-server/render.ts","transforms":[{"name":"__load__","result":"import { JSX } from \"solid-js\";\nimport { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FetchEvent, FETCH_EVENT, PageEvent } from \"../server/types\";\n\nexport function renderSync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          return await (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderAsync(\n  fn: (context: PageEvent) => JSX.Element,\n  options?: {\n    timeoutMs?: number;\n    nonce?: string;\n    renderId?: string;\n  }\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          }) as Response;\n        }\n\n        markup = handleIslandsRouting(pageEvent, markup);\n\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nexport function renderStream(\n  fn: (context: PageEvent) => JSX.Element,\n  baseOptions: {\n    nonce?: string;\n    renderId?: string;\n    onCompleteShell?: (info: { write: (v: string) => void }) => void;\n    onCompleteAll?: (info: { write: (v: string) => void }) => void;\n  } = {}\n) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event: FetchEvent): Promise<Response> {\n        if (\n          !import.meta.env.DEV &&\n          !import.meta.env.START_SSR &&\n          !import.meta.env.START_INDEX_HTML\n        ) {\n          const getStaticHTML = (\n            event as unknown as { env: { getStaticHTML(url: string | URL): Promise<Response> } }\n          ).env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n\n        let pageEvent = createPageEvent(event);\n\n        // Hijack after navigation with islands router to be async\n        // Todo streaming into HTML\n        if (import.meta.env.START_ISLANDS_ROUTER && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            }) as Response;\n          }\n\n          markup = handleIslandsRouting(pageEvent, markup);\n\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = options => {\n            handleStreamingRedirect(pageEvent)(options);\n            og(options);\n          };\n        } else options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n\n        handleStreamingIslandsRouting(pageEvent, writable);\n\n        stream.pipeTo(writable);\n\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\n\nfunction handleStreamingIslandsRouting(pageEvent: PageEvent, writable: WritableStream<any>) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\n\nfunction handleStreamingRedirect(context: PageEvent) {\n  return ({ write }: { write: (html: string) => void }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"</script>`);\n  };\n}\n\nfunction createPageEvent(event: FetchEvent) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n\n  let statusCode = 200;\n\n  function setStatusCode(code: number) {\n    statusCode = code;\n  }\n\n  function getStatusCode() {\n    return statusCode;\n  }\n\n  const pageEvent: PageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode: setStatusCode,\n    getStatusCode: getStatusCode,\n    fetch: internalFetch\n  });\n\n  return pageEvent;\n}\n\nfunction handleIslandsRouting(pageEvent: PageEvent, markup: string) {\n  if (\n    import.meta.env.START_ISLANDS_ROUTER &&\n    pageEvent.routerContext &&\n    pageEvent.routerContext.replaceOutletId\n  ) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${\n      pageEvent.routerContext.newOutletId\n    }=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) +\n        `<!--${pageEvent.routerContext.newOutletId}-->`.length +\n        `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) -\n        `</outlet-wrapper>`.length\n    )}`;\n\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n","start":1681089268770,"end":1681089268770},{"name":"vite:esbuild","result":"import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FETCH_EVENT } from \"../server/types\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !import.meta.env.START_SSR && !import.meta.env.START_INDEX_HTML) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (import.meta.env.START_ISLANDS_ROUTER && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (import.meta.env.START_ISLANDS_ROUTER && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n","start":1681089268770,"end":1681089268806,"order":"normal"},{"name":"vite:define","result":"import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"../api/internalFetch\";\nimport { apiRoutes } from \"../api/middleware\";\nimport { inlineServerFunctions } from \"../server/middleware\";\nimport { redirect } from \"../server/responses\";\nimport { FETCH_EVENT } from \"../server/types\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (false && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (false && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n","start":1681089268806,"end":1681089268806,"order":"normal"},{"name":"vite:import-analysis","result":"import.meta.env = {\"BASE_URL\":\"/\",\"MODE\":\"development\",\"DEV\":true,\"PROD\":false,\"SSR\":true};import.meta.env.START_SSR = true;import.meta.env.START_ISLANDS = false;import.meta.env.START_ENTRY_CLIENT = \"D:\\\\Files\\\\Github\\\\thaler\\\\examples\\\\solidstart\\\\src\\\\entry-client.tsx\";import.meta.env.START_ENTRY_SERVER = \"D:\\\\Files\\\\Github\\\\thaler\\\\examples\\\\solidstart\\\\src\\\\entry-server.tsx\";import.meta.env.START_INDEX_HTML = false;import.meta.env.START_ISLANDS_ROUTER = false;import.meta.env.START_ADAPTER = \"solid-start-node\";import { renderToStream, renderToString, renderToStringAsync } from \"solid-js/web\";\nimport { internalFetch } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/internalFetch.ts\";\nimport { apiRoutes } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/middleware.ts\";\nimport { inlineServerFunctions } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/middleware.ts\";\nimport { redirect } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/responses.ts\";\nimport { FETCH_EVENT } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/types.tsx\";\nexport function renderSync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          return await event.env.getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = renderToString(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderAsync(fn, options) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        let markup = await renderToStringAsync(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        markup = handleIslandsRouting(pageEvent, markup);\n        return new Response(markup, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nexport function renderStream(fn, baseOptions = {}) {\n  return () => apiRoutes({\n    forward: inlineServerFunctions({\n      async forward(event) {\n        if (!import.meta.env.DEV && !true && !false) {\n          const getStaticHTML = event.env.getStaticHTML;\n          return await getStaticHTML(\"/index\");\n        }\n        let pageEvent = createPageEvent(event);\n        if (false && event.request.headers.get(\"x-solid-referrer\")) {\n          let markup = await renderToStringAsync(() => fn(pageEvent), baseOptions);\n          if (pageEvent.routerContext && pageEvent.routerContext.url) {\n            return redirect(pageEvent.routerContext.url, {\n              headers: pageEvent.responseHeaders\n            });\n          }\n          markup = handleIslandsRouting(pageEvent, markup);\n          return new Response(markup, {\n            status: pageEvent.getStatusCode(),\n            headers: pageEvent.responseHeaders\n          });\n        }\n        const options = { ...baseOptions };\n        if (options.onCompleteAll) {\n          const og = options.onCompleteAll;\n          options.onCompleteAll = (options2) => {\n            handleStreamingRedirect(pageEvent)(options2);\n            og(options2);\n          };\n        } else\n          options.onCompleteAll = handleStreamingRedirect(pageEvent);\n        const { readable, writable } = new TransformStream();\n        const stream = renderToStream(() => fn(pageEvent), options);\n        if (pageEvent.routerContext && pageEvent.routerContext.url) {\n          return redirect(pageEvent.routerContext.url, {\n            headers: pageEvent.responseHeaders\n          });\n        }\n        handleStreamingIslandsRouting(pageEvent, writable);\n        stream.pipeTo(writable);\n        return new Response(readable, {\n          status: pageEvent.getStatusCode(),\n          headers: pageEvent.responseHeaders\n        });\n      }\n    })\n  });\n}\nfunction handleStreamingIslandsRouting(pageEvent, writable) {\n  if (pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    writer.write(\n      encoder.encode(\n        `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=`\n      )\n    );\n    writer.releaseLock();\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n}\nfunction handleStreamingRedirect(context) {\n  return ({ write }) => {\n    if (context.routerContext && context.routerContext.url)\n      write(`<script>window.location=\"${context.routerContext.url}\"<\\/script>`);\n  };\n}\nfunction createPageEvent(event) {\n  let responseHeaders = new Headers({\n    \"Content-Type\": \"text/html\"\n  });\n  const prevPath = event.request.headers.get(\"x-solid-referrer\");\n  let statusCode = 200;\n  function setStatusCode(code) {\n    statusCode = code;\n  }\n  function getStatusCode() {\n    return statusCode;\n  }\n  const pageEvent = Object.freeze({\n    request: event.request,\n    prevUrl: prevPath || \"\",\n    routerContext: {},\n    tags: [],\n    env: event.env,\n    clientAddress: event.clientAddress,\n    locals: event.locals,\n    $type: FETCH_EVENT,\n    responseHeaders,\n    setStatusCode,\n    getStatusCode,\n    fetch: internalFetch\n  });\n  return pageEvent;\n}\nfunction handleIslandsRouting(pageEvent, markup) {\n  if (false && pageEvent.routerContext && pageEvent.routerContext.replaceOutletId) {\n    markup = `${pageEvent.routerContext.replaceOutletId}:${pageEvent.routerContext.newOutletId}=${markup.slice(\n      markup.indexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) + `<!--${pageEvent.routerContext.newOutletId}-->`.length + `<outlet-wrapper id=\"${pageEvent.routerContext.newOutletId}\">`.length,\n      markup.lastIndexOf(`<!--${pageEvent.routerContext.newOutletId}-->`) - `</outlet-wrapper>`.length\n    )}`;\n    pageEvent.responseHeaders.set(\"Content-Type\", \"text/plain\");\n  }\n  return markup;\n}\n","start":1681089268806,"end":1681089268814,"order":"normal"}]}
