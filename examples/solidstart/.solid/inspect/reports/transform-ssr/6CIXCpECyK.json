{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/index.ts","transforms":[{"name":"__load__","result":"import { registerApiRoutes } from \"./internalFetch\";\nimport { getRouteMatches } from \"./router\";\nimport { MatchRoute, Method, Route } from \"./types\";\n\n// the line below will be replaced by the compiler with a configuration of routes\n// based on the files in src/routes\n// we have to declare this with `var` so that we can find it even if vite precompiles the code\n// @ts-ignore\nvar api = $API_ROUTES;\n\n// This is copied from https://github.com/solidjs/solid-router/blob/main/src/utils.ts\nfunction expandOptionals(pattern: string): string[] {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match) return [pattern];\n\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes: string[] = [prefix, (prefix += match[1])];\n\n  // This section handles adjacent optional params. We don't actually want all permuations since\n  // that will lead to equivalent routes which have the same number of params. For example\n  // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n  // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n  // ensure predictability where earlier params have precidence.\n  while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n    prefixes.push((prefix += match[1]));\n    suffix = suffix.slice(match[0].length);\n  }\n\n  return expandOptionals(suffix).reduce<string[]>(\n    (results, expansion) => [...results, ...prefixes.map(p => p + expansion)],\n    []\n  );\n}\n\nfunction routeToMatchRoute(route: Route): MatchRoute {\n  const segments = route.path.split(\"/\").filter(Boolean);\n\n  const params: { type: \"*\" | \":\"; name: string; index: number }[] = [];\n  const matchSegments: (string | null)[] = [];\n  let score = 0;\n  let wildcard = false;\n\n  for (const [index, segment] of segments.entries()) {\n    if (segment[0] === \":\") {\n      const name = segment.slice(1);\n      score += 3;\n      params.push({\n        type: \":\",\n        name,\n        index\n      });\n      matchSegments.push(null);\n    } else if (segment[0] === \"*\") {\n      score -= 1;\n      params.push({\n        type: \"*\",\n        name: segment.slice(1),\n        index\n      });\n      wildcard = true;\n    } else {\n      score += 4;\n      matchSegments.push(segment);\n    }\n  }\n\n  return {\n    ...route,\n    score,\n    params,\n    matchSegments,\n    wildcard\n  };\n}\n\nconst allRoutes = (api as Route[])\n  .flatMap(route => {\n    const paths = expandOptionals(route.path);\n    return paths.map(path => ({ ...route, path }));\n  })\n  .map(routeToMatchRoute)\n  .sort((a, b) => b.score - a.score);\n\nregisterApiRoutes(allRoutes);\n\nexport function getApiHandler(url: URL, method: string) {\n  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase() as Method);\n}\n\nexport function isApiRequest(request: Request) {\n  let apiHandler = getApiHandler(new URL(request.url), request.method);\n  return Boolean(apiHandler);\n}\n\nexport * from \"../server/responses\";\nexport type { APIEvent } from \"./types\";\n","start":1681089269152,"end":1681089269152},{"name":"solid-start-file-system-router","result":"import { registerApiRoutes } from \"./internalFetch\";\nimport { getRouteMatches } from \"./router\";\nimport { MatchRoute, Method, Route } from \"./types\";\n\n// the line below will be replaced by the compiler with a configuration of routes\n// based on the files in src/routes\n// we have to declare this with `var` so that we can find it even if vite precompiles the code\n// @ts-ignore\n\n  import  { GET as routeData0, POST as routeData1 } from '/Files/Github/thaler/examples/solidstart/src/routes/api/__thaler/[id].ts';\n  const api = [\n{\nGET: \"skip\",\n path: \"/\" \n},\n{\nGET: routeData0,\n POST: routeData1,\n path: \"/api/__thaler/:id\" \n}\n];\n\n// This is copied from https://github.com/solidjs/solid-router/blob/main/src/utils.ts\nfunction expandOptionals(pattern: string): string[] {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match) return [pattern];\n\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes: string[] = [prefix, (prefix += match[1])];\n\n  // This section handles adjacent optional params. We don't actually want all permuations since\n  // that will lead to equivalent routes which have the same number of params. For example\n  // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n  // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n  // ensure predictability where earlier params have precidence.\n  while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n    prefixes.push((prefix += match[1]));\n    suffix = suffix.slice(match[0].length);\n  }\n\n  return expandOptionals(suffix).reduce<string[]>(\n    (results, expansion) => [...results, ...prefixes.map(p => p + expansion)],\n    []\n  );\n}\n\nfunction routeToMatchRoute(route: Route): MatchRoute {\n  const segments = route.path.split(\"/\").filter(Boolean);\n\n  const params: { type: \"*\" | \":\"; name: string; index: number }[] = [];\n  const matchSegments: (string | null)[] = [];\n  let score = 0;\n  let wildcard = false;\n\n  for (const [index, segment] of segments.entries()) {\n    if (segment[0] === \":\") {\n      const name = segment.slice(1);\n      score += 3;\n      params.push({\n        type: \":\",\n        name,\n        index\n      });\n      matchSegments.push(null);\n    } else if (segment[0] === \"*\") {\n      score -= 1;\n      params.push({\n        type: \"*\",\n        name: segment.slice(1),\n        index\n      });\n      wildcard = true;\n    } else {\n      score += 4;\n      matchSegments.push(segment);\n    }\n  }\n\n  return {\n    ...route,\n    score,\n    params,\n    matchSegments,\n    wildcard\n  };\n}\n\nconst allRoutes = (api as Route[])\n  .flatMap(route => {\n    const paths = expandOptionals(route.path);\n    return paths.map(path => ({ ...route, path }));\n  })\n  .map(routeToMatchRoute)\n  .sort((a, b) => b.score - a.score);\n\nregisterApiRoutes(allRoutes);\n\nexport function getApiHandler(url: URL, method: string) {\n  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase() as Method);\n}\n\nexport function isApiRequest(request: Request) {\n  let apiHandler = getApiHandler(new URL(request.url), request.method);\n  return Boolean(apiHandler);\n}\n\nexport * from \"../server/responses\";\nexport type { APIEvent } from \"./types\";\n","start":1681089269152,"end":1681089269152,"order":"pre"},{"name":"vite:esbuild","result":"import { registerApiRoutes } from \"./internalFetch\";\nimport { getRouteMatches } from \"./router\";\nimport { GET as routeData0, POST as routeData1 } from \"/Files/Github/thaler/examples/solidstart/src/routes/api/__thaler/[id].ts\";\nconst api = [\n  {\n    GET: \"skip\",\n    path: \"/\"\n  },\n  {\n    GET: routeData0,\n    POST: routeData1,\n    path: \"/api/__thaler/:id\"\n  }\n];\nfunction expandOptionals(pattern) {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match)\n    return [pattern];\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes = [prefix, prefix += match[1]];\n  while (match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix)) {\n    prefixes.push(prefix += match[1]);\n    suffix = suffix.slice(match[0].length);\n  }\n  return expandOptionals(suffix).reduce(\n    (results, expansion) => [...results, ...prefixes.map((p) => p + expansion)],\n    []\n  );\n}\nfunction routeToMatchRoute(route) {\n  const segments = route.path.split(\"/\").filter(Boolean);\n  const params = [];\n  const matchSegments = [];\n  let score = 0;\n  let wildcard = false;\n  for (const [index, segment] of segments.entries()) {\n    if (segment[0] === \":\") {\n      const name = segment.slice(1);\n      score += 3;\n      params.push({\n        type: \":\",\n        name,\n        index\n      });\n      matchSegments.push(null);\n    } else if (segment[0] === \"*\") {\n      score -= 1;\n      params.push({\n        type: \"*\",\n        name: segment.slice(1),\n        index\n      });\n      wildcard = true;\n    } else {\n      score += 4;\n      matchSegments.push(segment);\n    }\n  }\n  return {\n    ...route,\n    score,\n    params,\n    matchSegments,\n    wildcard\n  };\n}\nconst allRoutes = api.flatMap((route) => {\n  const paths = expandOptionals(route.path);\n  return paths.map((path) => ({ ...route, path }));\n}).map(routeToMatchRoute).sort((a, b) => b.score - a.score);\nregisterApiRoutes(allRoutes);\nexport function getApiHandler(url, method) {\n  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase());\n}\nexport function isApiRequest(request) {\n  let apiHandler = getApiHandler(new URL(request.url), request.method);\n  return Boolean(apiHandler);\n}\nexport * from \"../server/responses\";\n","start":1681089269153,"end":1681089269169,"order":"normal"},{"name":"vite:define","result":"import { registerApiRoutes } from \"./internalFetch\";\nimport { getRouteMatches } from \"./router\";\nimport { GET as routeData0, POST as routeData1 } from \"/Files/Github/thaler/examples/solidstart/src/routes/api/__thaler/[id].ts\";\nconst api = [\n  {\n    GET: \"skip\",\n    path: \"/\"\n  },\n  {\n    GET: routeData0,\n    POST: routeData1,\n    path: \"/api/__thaler/:id\"\n  }\n];\nfunction expandOptionals(pattern) {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match)\n    return [pattern];\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes = [prefix, prefix += match[1]];\n  while (match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix)) {\n    prefixes.push(prefix += match[1]);\n    suffix = suffix.slice(match[0].length);\n  }\n  return expandOptionals(suffix).reduce(\n    (results, expansion) => [...results, ...prefixes.map((p) => p + expansion)],\n    []\n  );\n}\nfunction routeToMatchRoute(route) {\n  const segments = route.path.split(\"/\").filter(Boolean);\n  const params = [];\n  const matchSegments = [];\n  let score = 0;\n  let wildcard = false;\n  for (const [index, segment] of segments.entries()) {\n    if (segment[0] === \":\") {\n      const name = segment.slice(1);\n      score += 3;\n      params.push({\n        type: \":\",\n        name,\n        index\n      });\n      matchSegments.push(null);\n    } else if (segment[0] === \"*\") {\n      score -= 1;\n      params.push({\n        type: \"*\",\n        name: segment.slice(1),\n        index\n      });\n      wildcard = true;\n    } else {\n      score += 4;\n      matchSegments.push(segment);\n    }\n  }\n  return {\n    ...route,\n    score,\n    params,\n    matchSegments,\n    wildcard\n  };\n}\nconst allRoutes = api.flatMap((route) => {\n  const paths = expandOptionals(route.path);\n  return paths.map((path) => ({ ...route, path }));\n}).map(routeToMatchRoute).sort((a, b) => b.score - a.score);\nregisterApiRoutes(allRoutes);\nexport function getApiHandler(url, method) {\n  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase());\n}\nexport function isApiRequest(request) {\n  let apiHandler = getApiHandler(new URL(request.url), request.method);\n  return Boolean(apiHandler);\n}\nexport * from \"../server/responses\";\n","start":1681089269169,"end":1681089269169,"order":"normal"},{"name":"vite:import-analysis","result":"import { registerApiRoutes } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/internalFetch.ts\";\nimport { getRouteMatches } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/router.ts\";\nimport { GET as routeData0, POST as routeData1 } from \"/src/routes/api/__thaler/[id].ts\";\nconst api = [\n  {\n    GET: \"skip\",\n    path: \"/\"\n  },\n  {\n    GET: routeData0,\n    POST: routeData1,\n    path: \"/api/__thaler/:id\"\n  }\n];\nfunction expandOptionals(pattern) {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match)\n    return [pattern];\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes = [prefix, prefix += match[1]];\n  while (match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix)) {\n    prefixes.push(prefix += match[1]);\n    suffix = suffix.slice(match[0].length);\n  }\n  return expandOptionals(suffix).reduce(\n    (results, expansion) => [...results, ...prefixes.map((p) => p + expansion)],\n    []\n  );\n}\nfunction routeToMatchRoute(route) {\n  const segments = route.path.split(\"/\").filter(Boolean);\n  const params = [];\n  const matchSegments = [];\n  let score = 0;\n  let wildcard = false;\n  for (const [index, segment] of segments.entries()) {\n    if (segment[0] === \":\") {\n      const name = segment.slice(1);\n      score += 3;\n      params.push({\n        type: \":\",\n        name,\n        index\n      });\n      matchSegments.push(null);\n    } else if (segment[0] === \"*\") {\n      score -= 1;\n      params.push({\n        type: \"*\",\n        name: segment.slice(1),\n        index\n      });\n      wildcard = true;\n    } else {\n      score += 4;\n      matchSegments.push(segment);\n    }\n  }\n  return {\n    ...route,\n    score,\n    params,\n    matchSegments,\n    wildcard\n  };\n}\nconst allRoutes = api.flatMap((route) => {\n  const paths = expandOptionals(route.path);\n  return paths.map((path) => ({ ...route, path }));\n}).map(routeToMatchRoute).sort((a, b) => b.score - a.score);\nregisterApiRoutes(allRoutes);\nexport function getApiHandler(url, method) {\n  return getRouteMatches(allRoutes, url.pathname, method.toUpperCase());\n}\nexport function isApiRequest(request) {\n  let apiHandler = getApiHandler(new URL(request.url), request.method);\n  return Boolean(apiHandler);\n}\nexport * from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/responses.ts\";\n","start":1681089269169,"end":1681089269175,"order":"normal"}]}
