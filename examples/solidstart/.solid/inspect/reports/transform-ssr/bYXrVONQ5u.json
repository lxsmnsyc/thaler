{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/middleware.ts","transforms":[{"name":"__load__","result":"import { internalFetch } from \"../api/internalFetch\";\nimport { Middleware as ServerMiddleware } from \"../entry-server/StartServer\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"./responses\";\nimport { handleServerRequest, server$ } from \"./server-functions/server\";\nimport { FetchEvent, FETCH_EVENT } from \"./types\";\n\nexport const inlineServerFunctions: ServerMiddleware = ({ forward }) => {\n  return async (event: FetchEvent) => {\n    const url = new URL(event.request.url);\n\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n\n      let formRequestBody;\n      if (\n        contentType != null &&\n        contentType.includes(\"form\") &&\n        !(origin != null && origin.includes(\"client\"))\n      ) {\n        let [read1, read2] = event.request.body!.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        clientAddress: event.clientAddress,\n        locals: event.locals,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n\n      let responseContentType = serverResponse!.headers.get(XSolidStartContentTypeHeader);\n\n      // when a form POST action is made and there is an error throw,\n      // and its a non-javascript request potentially,\n      // we redirect to the referrer with the form state and error serialized\n      // in the url params for the redicted location\n      if (\n        formRequestBody &&\n        responseContentType !== null &&\n        responseContentType.includes(\"error\")\n      ) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location:\n              new URL(event.request.headers.get(\"referer\") || \"\").pathname +\n              \"?form=\" +\n              encodeURIComponent(\n                JSON.stringify({\n                  url: url.pathname,\n                  entries: entries,\n                  ...(await serverResponse!.json())\n                })\n              )\n          }\n        });\n      }\n      return serverResponse as Response;\n    }\n\n    const response = await forward(event);\n\n    return response;\n  };\n};\n","start":1681089268855,"end":1681089268855},{"name":"vite:esbuild","result":"import { internalFetch } from \"../api/internalFetch\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"./responses\";\nimport { handleServerRequest, server$ } from \"./server-functions/server\";\nimport { FETCH_EVENT } from \"./types\";\nexport const inlineServerFunctions = ({ forward }) => {\n  return async (event) => {\n    const url = new URL(event.request.url);\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n      let formRequestBody;\n      if (contentType != null && contentType.includes(\"form\") && !(origin != null && origin.includes(\"client\"))) {\n        let [read1, read2] = event.request.body.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        clientAddress: event.clientAddress,\n        locals: event.locals,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n      let responseContentType = serverResponse.headers.get(XSolidStartContentTypeHeader);\n      if (formRequestBody && responseContentType !== null && responseContentType.includes(\"error\")) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location: new URL(event.request.headers.get(\"referer\") || \"\").pathname + \"?form=\" + encodeURIComponent(\n              JSON.stringify({\n                url: url.pathname,\n                entries,\n                ...await serverResponse.json()\n              })\n            )\n          }\n        });\n      }\n      return serverResponse;\n    }\n    const response = await forward(event);\n    return response;\n  };\n};\n","start":1681089268855,"end":1681089269010,"order":"normal"},{"name":"vite:define","result":"import { internalFetch } from \"../api/internalFetch\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"./responses\";\nimport { handleServerRequest, server$ } from \"./server-functions/server\";\nimport { FETCH_EVENT } from \"./types\";\nexport const inlineServerFunctions = ({ forward }) => {\n  return async (event) => {\n    const url = new URL(event.request.url);\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n      let formRequestBody;\n      if (contentType != null && contentType.includes(\"form\") && !(origin != null && origin.includes(\"client\"))) {\n        let [read1, read2] = event.request.body.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        clientAddress: event.clientAddress,\n        locals: event.locals,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n      let responseContentType = serverResponse.headers.get(XSolidStartContentTypeHeader);\n      if (formRequestBody && responseContentType !== null && responseContentType.includes(\"error\")) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location: new URL(event.request.headers.get(\"referer\") || \"\").pathname + \"?form=\" + encodeURIComponent(\n              JSON.stringify({\n                url: url.pathname,\n                entries,\n                ...await serverResponse.json()\n              })\n            )\n          }\n        });\n      }\n      return serverResponse;\n    }\n    const response = await forward(event);\n    return response;\n  };\n};\n","start":1681089269010,"end":1681089269010,"order":"normal"},{"name":"vite:import-analysis","result":"import { internalFetch } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/api/internalFetch.ts\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/responses.ts\";\nimport { handleServerRequest, server$ } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/server-functions/server.ts\";\nimport { FETCH_EVENT } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.2.1/node_modules/solid-start/server/types.tsx\";\nexport const inlineServerFunctions = ({ forward }) => {\n  return async (event) => {\n    const url = new URL(event.request.url);\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n      let formRequestBody;\n      if (contentType != null && contentType.includes(\"form\") && !(origin != null && origin.includes(\"client\"))) {\n        let [read1, read2] = event.request.body.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        clientAddress: event.clientAddress,\n        locals: event.locals,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n      let responseContentType = serverResponse.headers.get(XSolidStartContentTypeHeader);\n      if (formRequestBody && responseContentType !== null && responseContentType.includes(\"error\")) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location: new URL(event.request.headers.get(\"referer\") || \"\").pathname + \"?form=\" + encodeURIComponent(\n              JSON.stringify({\n                url: url.pathname,\n                entries,\n                ...await serverResponse.json()\n              })\n            )\n          }\n        });\n      }\n      return serverResponse;\n    }\n    const response = await forward(event);\n    return response;\n  };\n};\n","start":1681089269010,"end":1681089269030,"order":"normal"}]}
