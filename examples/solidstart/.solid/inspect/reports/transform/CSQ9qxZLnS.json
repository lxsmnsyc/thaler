{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/@solidjs+router@0.8.2_solid-js@1.7.2/node_modules/@solidjs/router/dist/components.jsx?v=9590c33f","transforms":[{"name":"__load__","result":"/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = (props) => {\n    const { source, url, base, data, out } = props;\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\n    const routerState = createRouterContext(integration, base, data, out);\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\n};\nexport const Routes = (props) => {\n    const router = useRouter();\n    const parentRoute = useRoute();\n    const routeDefs = children(() => props.children);\n    const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n    const params = createMemoObject(() => {\n        const m = matches();\n        const params = {};\n        for (let i = 0; i < m.length; i++) {\n            Object.assign(params, m[i].params);\n        }\n        return params;\n    });\n    if (router.out) {\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\n            originalPath: route.originalPath,\n            pattern: route.pattern,\n            path,\n            params\n        })));\n    }\n    const disposers = [];\n    let root;\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\n        const next = [];\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\n            const prevMatch = prevMatches && prevMatches[i];\n            const nextMatch = nextMatches[i];\n            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n                next[i] = prev[i];\n            }\n            else {\n                equal = false;\n                if (disposers[i]) {\n                    disposers[i]();\n                }\n                createRoot(dispose => {\n                    disposers[i] = dispose;\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n                });\n            }\n        }\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\n        if (prev && equal) {\n            return prev;\n        }\n        root = next[0];\n        return next;\n    }));\n    return (<Show when={routeStates() && root} keyed>\n      {route => <RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport const useRoutes = (routes, base) => {\n    return () => <Routes base={base}>{routes}</Routes>;\n};\nexport const Route = (props) => {\n    const childRoutes = children(() => props.children);\n    return mergeProps(props, {\n        get children() {\n            return childRoutes();\n        }\n    });\n};\nexport const Outlet = () => {\n    const route = useRoute();\n    return (<Show when={route.child} keyed>\n      {child => <RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport function A(props) {\n    props = mergeProps({ inactiveClass: \"inactive\", activeClass: \"active\" }, props);\n    const [, rest] = splitProps(props, [\n        \"href\",\n        \"state\",\n        \"class\",\n        \"activeClass\",\n        \"inactiveClass\",\n        \"end\"\n    ]);\n    const to = useResolvedPath(() => props.href);\n    const href = useHref(to);\n    const location = useLocation();\n    const isActive = createMemo(() => {\n        const to_ = to();\n        if (to_ === undefined)\n            return false;\n        const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n        const loc = normalizePath(location.pathname).toLowerCase();\n        return props.end ? path === loc : loc.startsWith(path);\n    });\n    return (<a link {...rest} href={href() || props.href} state={JSON.stringify(props.state)} classList={{\n            ...(props.class && { [props.class]: true }),\n            [props.inactiveClass]: !isActive(),\n            [props.activeClass]: isActive(),\n            ...rest.classList\n        }} aria-current={isActive() ? \"page\" : undefined}/>);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { href, state } = props;\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\n    navigate(path, { replace: true, state });\n    return null;\n}\n","start":1681089272098,"end":1681089272098},{"name":"solid","result":"import { template as _$template } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { runHydrationEvents as _$runHydrationEvents } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { memo as _$memo } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<a link>`);\n/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return _$createComponent(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nexport const Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return _$createComponent(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => _$createComponent(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nexport const useRoutes = (routes, base) => {\n  return () => _$createComponent(Routes, {\n    base: base,\n    children: routes\n  });\n};\nexport const Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nexport const Outlet = () => {\n  const route = useRoute();\n  return _$createComponent(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => _$createComponent(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nexport function A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$);\n    _$spread(_el$, _$mergeProps(rest, {\n      get href() {\n        return href() || props.href;\n      },\n      get state() {\n        return JSON.stringify(props.state);\n      },\n      get classList() {\n        return {\n          ...(props.class && {\n            [props.class]: true\n          }),\n          [props.inactiveClass]: !isActive(),\n          [props.activeClass]: isActive(),\n          ...rest.classList\n        };\n      },\n      get [\"aria-current\"]() {\n        return isActive() ? \"page\" : undefined;\n      }\n    }), false, false);\n    _$runHydrationEvents();\n    return _el$;\n  })();\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}","start":1681089272098,"end":1681089272126,"order":"pre"},{"name":"vite:import-analysis","result":"import { template as _$template } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { getNextElement as _$getNextElement } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { runHydrationEvents as _$runHydrationEvents } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { spread as _$spread } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { mergeProps as _$mergeProps } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { memo as _$memo } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { createComponent as _$createComponent } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<a link>`);\n/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"/node_modules/.vite/deps/solid-js.js?v=9590c33f\";\nimport { isServer } from \"/node_modules/.vite/deps/solid-js_web.js?v=9590c33f\";\nimport { pathIntegration, staticIntegration } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/@solidjs+router@0.8.2_solid-js@1.7.2/node_modules/@solidjs/router/dist/integration.js?v=9590c33f\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/@solidjs+router@0.8.2_solid-js@1.7.2/node_modules/@solidjs/router/dist/routing.js?v=9590c33f\";\nimport { joinPaths, normalizePath, createMemoObject } from \"/@fs/D:/Files/Github/thaler/node_modules/.pnpm/@solidjs+router@0.8.2_solid-js@1.7.2/node_modules/@solidjs/router/dist/utils.js?v=9590c33f\";\nexport const Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return _$createComponent(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nexport const Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return _$createComponent(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => _$createComponent(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nexport const useRoutes = (routes, base) => {\n  return () => _$createComponent(Routes, {\n    base: base,\n    children: routes\n  });\n};\nexport const Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nexport const Outlet = () => {\n  const route = useRoute();\n  return _$createComponent(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => _$createComponent(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nexport function A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$);\n    _$spread(_el$, _$mergeProps(rest, {\n      get href() {\n        return href() || props.href;\n      },\n      get state() {\n        return JSON.stringify(props.state);\n      },\n      get classList() {\n        return {\n          ...(props.class && {\n            [props.class]: true\n          }),\n          [props.inactiveClass]: !isActive(),\n          [props.activeClass]: isActive(),\n          ...rest.classList\n        };\n      },\n      get [\"aria-current\"]() {\n        return isActive() ? \"page\" : undefined;\n      }\n    }), false, false);\n    _$runHydrationEvents();\n    return _el$;\n  })();\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}","start":1681089272126,"end":1681089272134,"order":"normal"}]}
