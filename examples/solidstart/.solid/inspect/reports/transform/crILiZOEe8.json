{"resolvedId":"D:/Files/Github/thaler/node_modules/.pnpm/vite@4.2.1_@types+node@18.14.1/node_modules/vite/dist/client/client.mjs","transforms":[{"name":"__load__","result":"import '@vite/env';\n\nconst base$1 = __BASE__ || '/';\n// set :host styles to make playwright detect the element as visible\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: var(--window-color);\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"backdrop\" part=\"backdrop\">\n  <div class=\"window\" part=\"window\">\n    <pre class=\"message\" part=\"message\"><span class=\"plugin\" part=\"plugin\"></span><span class=\"message-body\" part=\"message-body\"></span></pre>\n    <pre class=\"file\" part=\"file\"></pre>\n    <pre class=\"frame\" part=\"frame\"></pre>\n    <pre class=\"stack\" part=\"stack\"></pre>\n    <div class=\"tip\" part=\"tip\">\n      Click outside or fix the code to dismiss.<br>\n      You can also disable this overlay by setting\n      <code part=\"config-option-name\">server.hmr.overlay</code> to <code part=\"config-option-value\">false</code> in <code part=\"config-file-name\">vite.config.js.</code>\n    </div>\n  </div>\n</div>\n`;\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = template;\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(`${base$1}__open-in-editor?file=` + encodeURIComponent(file));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || '/';\nconst messageBuffer = [];\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        console.log(`[vite] server connection lost. polling for restart...`);\n        await waitForSuccessfulPing(protocol, hostAndPath);\n        location.reload();\n    });\n    return socket;\n}\nfunction warnFailedFetch(err, path) {\n    if (!err.message.match('fetch')) {\n        console.error(err);\n    }\n    console.error(`[hmr] Failed to reload ${path}. ` +\n        `This could be due to syntax errors or importing non-existent ` +\n        `modules. (see errors above)`);\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, location.toString());\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            sendMessageBuffer();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, __HMR_TIMEOUT__);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            // if this is the first update and there's already an error overlay, it\n            // means the page opened with existing server compile error and the whole\n            // module script failed to load (since one of the nested imports is 500).\n            // in this case a normal update won't work and a full reload is needed.\n            if (isFirstUpdate && hasErrorOverlay()) {\n                window.location.reload();\n                return;\n            }\n            else {\n                clearErrorOverlay();\n                isFirstUpdate = false;\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return queueUpdate(fetchUpdate(update));\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (payload.path && payload.path.endsWith('.html')) {\n                // if html file is edited, only reload the page if the browser is\n                // currently on that page.\n                const pagePath = decodeURI(location.pathname);\n                const payloadPath = base + payload.path.slice(1);\n                if (pagePath === payloadPath ||\n                    payload.path === '/index.html' ||\n                    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                    location.reload();\n                }\n                return;\n            }\n            else {\n                location.reload();\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            // After an HMR update, some modules are no longer imported on the page\n            // but they may have left behind side effects that need to be cleaned up\n            // (.e.g style injections)\n            // TODO Trigger their dispose callbacks.\n            payload.paths.forEach((path) => {\n                const fn = pruneMap.get(path);\n                if (fn) {\n                    fn(dataMap.get(path));\n                }\n            });\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            const err = payload.err;\n            if (enableOverlay) {\n                createErrorOverlay(err);\n            }\n            else {\n                console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    const cbs = customListenersMap.get(event);\n    if (cbs) {\n        cbs.forEach((cb) => cb(data));\n    }\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nfunction createErrorOverlay(err) {\n    if (!enableOverlay)\n        return;\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document\n        .querySelectorAll(overlayId)\n        .forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nlet pending = false;\nlet queued = [];\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p) {\n    queued.push(p);\n    if (!pending) {\n        pending = true;\n        await Promise.resolve();\n        pending = false;\n        const loading = [...queued];\n        queued = [];\n        (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            // A fetch on a websocket URL will return a successful promise with status 400,\n            // but will reject a networking error.\n            // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n            });\n            break;\n        }\n        catch (e) {\n            // wait ms before attempting to ping again\n            await new Promise((resolve) => setTimeout(resolve, ms));\n        }\n    }\n}\nconst sheetsMap = new Map();\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nasync function fetchUpdate({ path, acceptedPath, timestamp, explicitImportRequired, }) {\n    const mod = hotModulesMap.get(path);\n    if (!mod) {\n        // In a code-splitting project,\n        // it is common that the hot-updating module is not loaded yet.\n        // https://github.com/vitejs/vite/issues/721\n        return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    // determine the qualified callbacks before we re-import the modules\n    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n        const disposer = disposeMap.get(acceptedPath);\n        if (disposer)\n            await disposer(dataMap.get(acceptedPath));\n        const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n        try {\n            fetchedModule = await import(\n            /* @vite-ignore */\n            base +\n                acceptedPathWithoutQuery.slice(1) +\n                `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n        }\n        catch (e) {\n            warnFailedFetch(e, acceptedPath);\n        }\n    }\n    return () => {\n        for (const { deps, fn } of qualifiedCallbacks) {\n            fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        console.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n}\nfunction sendMessageBuffer() {\n    if (socket.readyState === 1) {\n        messageBuffer.forEach((msg) => socket.send(msg));\n        messageBuffer.length = 0;\n    }\n}\nconst hotModulesMap = new Map();\nconst disposeMap = new Map();\nconst pruneMap = new Map();\nconst dataMap = new Map();\nconst customListenersMap = new Map();\nconst ctxToListenersMap = new Map();\nfunction createHotContext(ownerPath) {\n    if (!dataMap.has(ownerPath)) {\n        dataMap.set(ownerPath, {});\n    }\n    // when a file is hot updated, a new context is created\n    // clear its stale callbacks\n    const mod = hotModulesMap.get(ownerPath);\n    if (mod) {\n        mod.callbacks = [];\n    }\n    // clear stale custom event listeners\n    const staleListeners = ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n        for (const [event, staleFns] of staleListeners) {\n            const listeners = customListenersMap.get(event);\n            if (listeners) {\n                customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n            }\n        }\n    }\n    const newListeners = new Map();\n    ctxToListenersMap.set(ownerPath, newListeners);\n    function acceptDeps(deps, callback = () => { }) {\n        const mod = hotModulesMap.get(ownerPath) || {\n            id: ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        hotModulesMap.set(ownerPath, mod);\n    }\n    const hot = {\n        get data() {\n            return dataMap.get(ownerPath);\n        },\n        accept(deps, callback) {\n            if (typeof deps === 'function' || !deps) {\n                // self-accept: hot.accept(() => {})\n                acceptDeps([ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n            }\n            else if (typeof deps === 'string') {\n                // explicit deps\n                acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n            }\n            else if (Array.isArray(deps)) {\n                acceptDeps(deps, callback);\n            }\n            else {\n                throw new Error(`invalid hot.accept() usage.`);\n            }\n        },\n        // export names (first arg) are irrelevant on the client side, they're\n        // extracted in the server for propagation\n        acceptExports(_, callback) {\n            acceptDeps([ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        },\n        dispose(cb) {\n            disposeMap.set(ownerPath, cb);\n        },\n        prune(cb) {\n            pruneMap.set(ownerPath, cb);\n        },\n        // Kept for backward compatibility (#11036)\n        // @ts-expect-error untyped\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        decline() { },\n        // tell the server to re-perform hmr propagation from this module as root\n        invalidate(message) {\n            notifyListeners('vite:invalidate', { path: ownerPath, message });\n            this.send('vite:invalidate', { path: ownerPath, message });\n            console.debug(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ''}`);\n        },\n        // custom events\n        on(event, cb) {\n            const addToMap = (map) => {\n                const existing = map.get(event) || [];\n                existing.push(cb);\n                map.set(event, existing);\n            };\n            addToMap(customListenersMap);\n            addToMap(newListeners);\n        },\n        send(event, data) {\n            messageBuffer.push(JSON.stringify({ type: 'custom', event, data }));\n            sendMessageBuffer();\n        },\n    };\n    return hot;\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (!url.startsWith('.') && !url.startsWith('/')) {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n","start":1681089271680,"end":1681089271680},{"name":"vite:client-inject","result":"import '@vite/env';\n\nconst base$1 = \"/\" || '/';\n// set :host styles to make playwright detect the element as visible\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: var(--window-color);\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"backdrop\" part=\"backdrop\">\n  <div class=\"window\" part=\"window\">\n    <pre class=\"message\" part=\"message\"><span class=\"plugin\" part=\"plugin\"></span><span class=\"message-body\" part=\"message-body\"></span></pre>\n    <pre class=\"file\" part=\"file\"></pre>\n    <pre class=\"frame\" part=\"frame\"></pre>\n    <pre class=\"stack\" part=\"stack\"></pre>\n    <div class=\"tip\" part=\"tip\">\n      Click outside or fix the code to dismiss.<br>\n      You can also disable this overlay by setting\n      <code part=\"config-option-name\">server.hmr.overlay</code> to <code part=\"config-option-value\">false</code> in <code part=\"config-file-name\">vite.config.js.</code>\n    </div>\n  </div>\n</div>\n`;\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = template;\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(`${base$1}__open-in-editor?file=` + encodeURIComponent(file));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = \"localhost:3000/\";\nconst socketProtocol = null || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:3000/\";\nconst base = \"/\" || '/';\nconst messageBuffer = [];\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        console.log(`[vite] server connection lost. polling for restart...`);\n        await waitForSuccessfulPing(protocol, hostAndPath);\n        location.reload();\n    });\n    return socket;\n}\nfunction warnFailedFetch(err, path) {\n    if (!err.message.match('fetch')) {\n        console.error(err);\n    }\n    console.error(`[hmr] Failed to reload ${path}. ` +\n        `This could be due to syntax errors or importing non-existent ` +\n        `modules. (see errors above)`);\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, location.toString());\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            sendMessageBuffer();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, 30000);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            // if this is the first update and there's already an error overlay, it\n            // means the page opened with existing server compile error and the whole\n            // module script failed to load (since one of the nested imports is 500).\n            // in this case a normal update won't work and a full reload is needed.\n            if (isFirstUpdate && hasErrorOverlay()) {\n                window.location.reload();\n                return;\n            }\n            else {\n                clearErrorOverlay();\n                isFirstUpdate = false;\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return queueUpdate(fetchUpdate(update));\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (payload.path && payload.path.endsWith('.html')) {\n                // if html file is edited, only reload the page if the browser is\n                // currently on that page.\n                const pagePath = decodeURI(location.pathname);\n                const payloadPath = base + payload.path.slice(1);\n                if (pagePath === payloadPath ||\n                    payload.path === '/index.html' ||\n                    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                    location.reload();\n                }\n                return;\n            }\n            else {\n                location.reload();\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            // After an HMR update, some modules are no longer imported on the page\n            // but they may have left behind side effects that need to be cleaned up\n            // (.e.g style injections)\n            // TODO Trigger their dispose callbacks.\n            payload.paths.forEach((path) => {\n                const fn = pruneMap.get(path);\n                if (fn) {\n                    fn(dataMap.get(path));\n                }\n            });\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            const err = payload.err;\n            if (enableOverlay) {\n                createErrorOverlay(err);\n            }\n            else {\n                console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    const cbs = customListenersMap.get(event);\n    if (cbs) {\n        cbs.forEach((cb) => cb(data));\n    }\n}\nconst enableOverlay = true;\nfunction createErrorOverlay(err) {\n    if (!enableOverlay)\n        return;\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document\n        .querySelectorAll(overlayId)\n        .forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nlet pending = false;\nlet queued = [];\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p) {\n    queued.push(p);\n    if (!pending) {\n        pending = true;\n        await Promise.resolve();\n        pending = false;\n        const loading = [...queued];\n        queued = [];\n        (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            // A fetch on a websocket URL will return a successful promise with status 400,\n            // but will reject a networking error.\n            // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n            });\n            break;\n        }\n        catch (e) {\n            // wait ms before attempting to ping again\n            await new Promise((resolve) => setTimeout(resolve, ms));\n        }\n    }\n}\nconst sheetsMap = new Map();\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nasync function fetchUpdate({ path, acceptedPath, timestamp, explicitImportRequired, }) {\n    const mod = hotModulesMap.get(path);\n    if (!mod) {\n        // In a code-splitting project,\n        // it is common that the hot-updating module is not loaded yet.\n        // https://github.com/vitejs/vite/issues/721\n        return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    // determine the qualified callbacks before we re-import the modules\n    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n        const disposer = disposeMap.get(acceptedPath);\n        if (disposer)\n            await disposer(dataMap.get(acceptedPath));\n        const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n        try {\n            fetchedModule = await import(\n            /* @vite-ignore */\n            base +\n                acceptedPathWithoutQuery.slice(1) +\n                `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n        }\n        catch (e) {\n            warnFailedFetch(e, acceptedPath);\n        }\n    }\n    return () => {\n        for (const { deps, fn } of qualifiedCallbacks) {\n            fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        console.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n}\nfunction sendMessageBuffer() {\n    if (socket.readyState === 1) {\n        messageBuffer.forEach((msg) => socket.send(msg));\n        messageBuffer.length = 0;\n    }\n}\nconst hotModulesMap = new Map();\nconst disposeMap = new Map();\nconst pruneMap = new Map();\nconst dataMap = new Map();\nconst customListenersMap = new Map();\nconst ctxToListenersMap = new Map();\nfunction createHotContext(ownerPath) {\n    if (!dataMap.has(ownerPath)) {\n        dataMap.set(ownerPath, {});\n    }\n    // when a file is hot updated, a new context is created\n    // clear its stale callbacks\n    const mod = hotModulesMap.get(ownerPath);\n    if (mod) {\n        mod.callbacks = [];\n    }\n    // clear stale custom event listeners\n    const staleListeners = ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n        for (const [event, staleFns] of staleListeners) {\n            const listeners = customListenersMap.get(event);\n            if (listeners) {\n                customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n            }\n        }\n    }\n    const newListeners = new Map();\n    ctxToListenersMap.set(ownerPath, newListeners);\n    function acceptDeps(deps, callback = () => { }) {\n        const mod = hotModulesMap.get(ownerPath) || {\n            id: ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        hotModulesMap.set(ownerPath, mod);\n    }\n    const hot = {\n        get data() {\n            return dataMap.get(ownerPath);\n        },\n        accept(deps, callback) {\n            if (typeof deps === 'function' || !deps) {\n                // self-accept: hot.accept(() => {})\n                acceptDeps([ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n            }\n            else if (typeof deps === 'string') {\n                // explicit deps\n                acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n            }\n            else if (Array.isArray(deps)) {\n                acceptDeps(deps, callback);\n            }\n            else {\n                throw new Error(`invalid hot.accept() usage.`);\n            }\n        },\n        // export names (first arg) are irrelevant on the client side, they're\n        // extracted in the server for propagation\n        acceptExports(_, callback) {\n            acceptDeps([ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        },\n        dispose(cb) {\n            disposeMap.set(ownerPath, cb);\n        },\n        prune(cb) {\n            pruneMap.set(ownerPath, cb);\n        },\n        // Kept for backward compatibility (#11036)\n        // @ts-expect-error untyped\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        decline() { },\n        // tell the server to re-perform hmr propagation from this module as root\n        invalidate(message) {\n            notifyListeners('vite:invalidate', { path: ownerPath, message });\n            this.send('vite:invalidate', { path: ownerPath, message });\n            console.debug(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ''}`);\n        },\n        // custom events\n        on(event, cb) {\n            const addToMap = (map) => {\n                const existing = map.get(event) || [];\n                existing.push(cb);\n                map.set(event, existing);\n            };\n            addToMap(customListenersMap);\n            addToMap(newListeners);\n        },\n        send(event, data) {\n            messageBuffer.push(JSON.stringify({ type: 'custom', event, data }));\n            sendMessageBuffer();\n        },\n    };\n    return hot;\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (!url.startsWith('.') && !url.startsWith('/')) {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n","start":1681089271680,"end":1681089271684,"order":"normal"},{"name":"vite:import-analysis","result":"import '/@fs/D:/Files/Github/thaler/node_modules/.pnpm/vite@4.2.1_@types+node@18.14.1/node_modules/vite/dist/client/env.mjs';\n\nconst base$1 = \"/\" || '/';\n// set :host styles to make playwright detect the element as visible\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: var(--window-color);\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"backdrop\" part=\"backdrop\">\n  <div class=\"window\" part=\"window\">\n    <pre class=\"message\" part=\"message\"><span class=\"plugin\" part=\"plugin\"></span><span class=\"message-body\" part=\"message-body\"></span></pre>\n    <pre class=\"file\" part=\"file\"></pre>\n    <pre class=\"frame\" part=\"frame\"></pre>\n    <pre class=\"stack\" part=\"stack\"></pre>\n    <div class=\"tip\" part=\"tip\">\n      Click outside or fix the code to dismiss.<br>\n      You can also disable this overlay by setting\n      <code part=\"config-option-name\">server.hmr.overlay</code> to <code part=\"config-option-value\">false</code> in <code part=\"config-file-name\">vite.config.js.</code>\n    </div>\n  </div>\n</div>\n`;\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = template;\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(`${base$1}__open-in-editor?file=` + encodeURIComponent(file));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = \"localhost:3000/\";\nconst socketProtocol = null || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:3000/\";\nconst base = \"/\" || '/';\nconst messageBuffer = [];\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        console.log(`[vite] server connection lost. polling for restart...`);\n        await waitForSuccessfulPing(protocol, hostAndPath);\n        location.reload();\n    });\n    return socket;\n}\nfunction warnFailedFetch(err, path) {\n    if (!err.message.match('fetch')) {\n        console.error(err);\n    }\n    console.error(`[hmr] Failed to reload ${path}. ` +\n        `This could be due to syntax errors or importing non-existent ` +\n        `modules. (see errors above)`);\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, location.toString());\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            sendMessageBuffer();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, 30000);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            // if this is the first update and there's already an error overlay, it\n            // means the page opened with existing server compile error and the whole\n            // module script failed to load (since one of the nested imports is 500).\n            // in this case a normal update won't work and a full reload is needed.\n            if (isFirstUpdate && hasErrorOverlay()) {\n                window.location.reload();\n                return;\n            }\n            else {\n                clearErrorOverlay();\n                isFirstUpdate = false;\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return queueUpdate(fetchUpdate(update));\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (payload.path && payload.path.endsWith('.html')) {\n                // if html file is edited, only reload the page if the browser is\n                // currently on that page.\n                const pagePath = decodeURI(location.pathname);\n                const payloadPath = base + payload.path.slice(1);\n                if (pagePath === payloadPath ||\n                    payload.path === '/index.html' ||\n                    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                    location.reload();\n                }\n                return;\n            }\n            else {\n                location.reload();\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            // After an HMR update, some modules are no longer imported on the page\n            // but they may have left behind side effects that need to be cleaned up\n            // (.e.g style injections)\n            // TODO Trigger their dispose callbacks.\n            payload.paths.forEach((path) => {\n                const fn = pruneMap.get(path);\n                if (fn) {\n                    fn(dataMap.get(path));\n                }\n            });\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            const err = payload.err;\n            if (enableOverlay) {\n                createErrorOverlay(err);\n            }\n            else {\n                console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    const cbs = customListenersMap.get(event);\n    if (cbs) {\n        cbs.forEach((cb) => cb(data));\n    }\n}\nconst enableOverlay = true;\nfunction createErrorOverlay(err) {\n    if (!enableOverlay)\n        return;\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document\n        .querySelectorAll(overlayId)\n        .forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nlet pending = false;\nlet queued = [];\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p) {\n    queued.push(p);\n    if (!pending) {\n        pending = true;\n        await Promise.resolve();\n        pending = false;\n        const loading = [...queued];\n        queued = [];\n        (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            // A fetch on a websocket URL will return a successful promise with status 400,\n            // but will reject a networking error.\n            // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n            });\n            break;\n        }\n        catch (e) {\n            // wait ms before attempting to ping again\n            await new Promise((resolve) => setTimeout(resolve, ms));\n        }\n    }\n}\nconst sheetsMap = new Map();\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nasync function fetchUpdate({ path, acceptedPath, timestamp, explicitImportRequired, }) {\n    const mod = hotModulesMap.get(path);\n    if (!mod) {\n        // In a code-splitting project,\n        // it is common that the hot-updating module is not loaded yet.\n        // https://github.com/vitejs/vite/issues/721\n        return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    // determine the qualified callbacks before we re-import the modules\n    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n        const disposer = disposeMap.get(acceptedPath);\n        if (disposer)\n            await disposer(dataMap.get(acceptedPath));\n        const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n        try {\n            fetchedModule = await import(\n            /* @vite-ignore */\n            base +\n                acceptedPathWithoutQuery.slice(1) +\n                `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n        }\n        catch (e) {\n            warnFailedFetch(e, acceptedPath);\n        }\n    }\n    return () => {\n        for (const { deps, fn } of qualifiedCallbacks) {\n            fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        console.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n}\nfunction sendMessageBuffer() {\n    if (socket.readyState === 1) {\n        messageBuffer.forEach((msg) => socket.send(msg));\n        messageBuffer.length = 0;\n    }\n}\nconst hotModulesMap = new Map();\nconst disposeMap = new Map();\nconst pruneMap = new Map();\nconst dataMap = new Map();\nconst customListenersMap = new Map();\nconst ctxToListenersMap = new Map();\nfunction createHotContext(ownerPath) {\n    if (!dataMap.has(ownerPath)) {\n        dataMap.set(ownerPath, {});\n    }\n    // when a file is hot updated, a new context is created\n    // clear its stale callbacks\n    const mod = hotModulesMap.get(ownerPath);\n    if (mod) {\n        mod.callbacks = [];\n    }\n    // clear stale custom event listeners\n    const staleListeners = ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n        for (const [event, staleFns] of staleListeners) {\n            const listeners = customListenersMap.get(event);\n            if (listeners) {\n                customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n            }\n        }\n    }\n    const newListeners = new Map();\n    ctxToListenersMap.set(ownerPath, newListeners);\n    function acceptDeps(deps, callback = () => { }) {\n        const mod = hotModulesMap.get(ownerPath) || {\n            id: ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        hotModulesMap.set(ownerPath, mod);\n    }\n    const hot = {\n        get data() {\n            return dataMap.get(ownerPath);\n        },\n        accept(deps, callback) {\n            if (typeof deps === 'function' || !deps) {\n                // self-accept: hot.accept(() => {})\n                acceptDeps([ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n            }\n            else if (typeof deps === 'string') {\n                // explicit deps\n                acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n            }\n            else if (Array.isArray(deps)) {\n                acceptDeps(deps, callback);\n            }\n            else {\n                throw new Error(`invalid hot.accept() usage.`);\n            }\n        },\n        // export names (first arg) are irrelevant on the client side, they're\n        // extracted in the server for propagation\n        acceptExports(_, callback) {\n            acceptDeps([ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        },\n        dispose(cb) {\n            disposeMap.set(ownerPath, cb);\n        },\n        prune(cb) {\n            pruneMap.set(ownerPath, cb);\n        },\n        // Kept for backward compatibility (#11036)\n        // @ts-expect-error untyped\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        decline() { },\n        // tell the server to re-perform hmr propagation from this module as root\n        invalidate(message) {\n            notifyListeners('vite:invalidate', { path: ownerPath, message });\n            this.send('vite:invalidate', { path: ownerPath, message });\n            console.debug(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ''}`);\n        },\n        // custom events\n        on(event, cb) {\n            const addToMap = (map) => {\n                const existing = map.get(event) || [];\n                existing.push(cb);\n                map.set(event, existing);\n            };\n            addToMap(customListenersMap);\n            addToMap(newListeners);\n        },\n        send(event, data) {\n            messageBuffer.push(JSON.stringify({ type: 'custom', event, data }));\n            sendMessageBuffer();\n        },\n    };\n    return hot;\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (!url.startsWith('.') && !url.startsWith('/')) {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n","start":1681089271684,"end":1681089271688,"order":"normal"}]}
